(* File auto-generated by obus-gen-interface, DO NOT EDIT. *)
open OBus_value
open OBus_value.C
open OBus_member
open OBus_object

module Org_freedesktop_DBus = struct
  let interface = "org.freedesktop.DBus"

  type type_start_service_by_name_result = [ `Already_running | `Success ]

  let cast_start_service_by_name_result = function
    | `Already_running -> 2l
    | `Success -> 1l

  let make_start_service_by_name_result = function
    | 2l -> `Already_running
    | 1l -> `Success
    | n ->
        Printf.ksprintf failwith
          "invalid value for \"start_service_by_name_result\": %ld" n

  type type_release_name_result = [ `Not_owner | `Non_existent | `Released ]

  let cast_release_name_result = function
    | `Not_owner -> 3l
    | `Non_existent -> 2l
    | `Released -> 1l

  let make_release_name_result = function
    | 3l -> `Not_owner
    | 2l -> `Non_existent
    | 1l -> `Released
    | n ->
        Printf.ksprintf failwith
          "invalid value for \"release_name_result\": %ld" n

  type type_request_name_result =
    [ `Already_owner | `Exists | `In_queue | `Primary_owner ]

  let cast_request_name_result = function
    | `Already_owner -> 4l
    | `Exists -> 3l
    | `In_queue -> 2l
    | `Primary_owner -> 1l

  let make_request_name_result = function
    | 4l -> `Already_owner
    | 3l -> `Exists
    | 2l -> `In_queue
    | 1l -> `Primary_owner
    | n ->
        Printf.ksprintf failwith
          "invalid value for \"request_name_result\": %ld" n

  type type_request_name_flags =
    [ `Do_not_queue | `Replace_existing | `Allow_replacement ]

  let cast_request_name_flags l =
    let rec loop acc = function
      | [] -> acc
      | `Do_not_queue :: rest -> loop (Int32.logor acc 4l) rest
      | `Replace_existing :: rest -> loop (Int32.logor acc 2l) rest
      | `Allow_replacement :: rest -> loop (Int32.logor acc 1l) rest
    in
    loop 0l l

  let make_request_name_flags n =
    let l = [] in
    let l = if Int32.logand n 4l <> 0l then `Do_not_queue :: l else l in
    let l = if Int32.logand n 2l <> 0l then `Replace_existing :: l else l in
    let l = if Int32.logand n 1l <> 0l then `Allow_replacement :: l else l in
    l

  let m_AddMatch =
    {
      Method.interface;
      Method.member = "AddMatch";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg0;
      Method.annotations = [];
    }

  let m_GetAdtAuditSessionData =
    {
      Method.interface;
      Method.member = "GetAdtAuditSessionData";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg1 (Some "x1", byte_array);
      Method.annotations = [];
    }

  let m_GetConnectionSELinuxSecurityContext =
    {
      Method.interface;
      Method.member = "GetConnectionSELinuxSecurityContext";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg1 (Some "x1", byte_array);
      Method.annotations = [];
    }

  let m_GetConnectionUnixProcessID =
    {
      Method.interface;
      Method.member = "GetConnectionUnixProcessID";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg1 (Some "x1", basic_uint32);
      Method.annotations = [];
    }

  let m_GetConnectionUnixUser =
    {
      Method.interface;
      Method.member = "GetConnectionUnixUser";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg1 (Some "x1", basic_uint32);
      Method.annotations = [];
    }

  let m_GetId =
    {
      Method.interface;
      Method.member = "GetId";
      Method.i_args = arg0;
      Method.o_args = arg1 (Some "x1", basic_string);
      Method.annotations = [];
    }

  let m_GetNameOwner =
    {
      Method.interface;
      Method.member = "GetNameOwner";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg1 (Some "x1", basic_string);
      Method.annotations = [];
    }

  let m_Hello =
    {
      Method.interface;
      Method.member = "Hello";
      Method.i_args = arg0;
      Method.o_args = arg1 (Some "name", basic_string);
      Method.annotations = [];
    }

  let m_ListActivatableNames =
    {
      Method.interface;
      Method.member = "ListActivatableNames";
      Method.i_args = arg0;
      Method.o_args = arg1 (Some "x1", array basic_string);
      Method.annotations = [];
    }

  let m_ListNames =
    {
      Method.interface;
      Method.member = "ListNames";
      Method.i_args = arg0;
      Method.o_args = arg1 (Some "x1", array basic_string);
      Method.annotations = [];
    }

  let m_ListQueuedOwners =
    {
      Method.interface;
      Method.member = "ListQueuedOwners";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg1 (Some "x1", array basic_string);
      Method.annotations = [];
    }

  let m_NameHasOwner =
    {
      Method.interface;
      Method.member = "NameHasOwner";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg1 (Some "x1", basic_boolean);
      Method.annotations = [];
    }

  let m_ReleaseName =
    {
      Method.interface;
      Method.member = "ReleaseName";
      Method.i_args = arg1 (Some "name", basic_string);
      Method.o_args = arg1 (Some "result", basic_uint32);
      Method.annotations =
        [ (OBus_introspect_ext.obus_otype, "release_name_result") ];
    }

  let m_ReloadConfig =
    {
      Method.interface;
      Method.member = "ReloadConfig";
      Method.i_args = arg0;
      Method.o_args = arg0;
      Method.annotations = [];
    }

  let m_RemoveMatch =
    {
      Method.interface;
      Method.member = "RemoveMatch";
      Method.i_args = arg1 (Some "x1", basic_string);
      Method.o_args = arg0;
      Method.annotations = [];
    }

  let m_RequestName =
    {
      Method.interface;
      Method.member = "RequestName";
      Method.i_args =
        arg2 (Some "name", basic_string) (Some "flags", basic_uint32);
      Method.o_args = arg1 (Some "result", basic_uint32);
      Method.annotations =
        [
          (OBus_introspect_ext.obus_otype, "request_name_result");
          (OBus_introspect_ext.obus_itype, "<string,request_name_flags>");
        ];
    }

  let m_StartServiceByName =
    {
      Method.interface;
      Method.member = "StartServiceByName";
      Method.i_args =
        arg2 (Some "name", basic_string) (Some "flags", basic_uint32);
      Method.o_args = arg1 (Some "result", basic_uint32);
      Method.annotations =
        [ (OBus_introspect_ext.obus_otype, "start_service_by_name_result") ];
    }

  let m_UpdateActivationEnvironment =
    {
      Method.interface;
      Method.member = "UpdateActivationEnvironment";
      Method.i_args = arg1 (Some "x1", dict string basic_string);
      Method.o_args = arg0;
      Method.annotations = [];
    }

  let s_NameAcquired =
    {
      Signal.interface;
      Signal.member = "NameAcquired";
      Signal.args = arg1 (Some "x1", basic_string);
      Signal.annotations = [];
    }

  let s_NameLost =
    {
      Signal.interface;
      Signal.member = "NameLost";
      Signal.args = arg1 (Some "x1", basic_string);
      Signal.annotations = [];
    }

  let s_NameOwnerChanged =
    {
      Signal.interface;
      Signal.member = "NameOwnerChanged";
      Signal.args =
        arg3 (Some "x1", basic_string) (Some "x2", basic_string)
          (Some "x3", basic_string);
      Signal.annotations = [];
    }

  type 'a members = {
    m_AddMatch : 'a OBus_object.t -> string -> unit Lwt.t;
    m_GetAdtAuditSessionData : 'a OBus_object.t -> string -> string Lwt.t;
    m_GetConnectionSELinuxSecurityContext :
      'a OBus_object.t -> string -> string Lwt.t;
    m_GetConnectionUnixProcessID : 'a OBus_object.t -> string -> int32 Lwt.t;
    m_GetConnectionUnixUser : 'a OBus_object.t -> string -> int32 Lwt.t;
    m_GetId : 'a OBus_object.t -> unit -> string Lwt.t;
    m_GetNameOwner : 'a OBus_object.t -> string -> string Lwt.t;
    m_Hello : 'a OBus_object.t -> unit -> string Lwt.t;
    m_ListActivatableNames : 'a OBus_object.t -> unit -> string list Lwt.t;
    m_ListNames : 'a OBus_object.t -> unit -> string list Lwt.t;
    m_ListQueuedOwners : 'a OBus_object.t -> string -> string list Lwt.t;
    m_NameHasOwner : 'a OBus_object.t -> string -> bool Lwt.t;
    m_ReleaseName : 'a OBus_object.t -> string -> int32 Lwt.t;
    m_ReloadConfig : 'a OBus_object.t -> unit -> unit Lwt.t;
    m_RemoveMatch : 'a OBus_object.t -> string -> unit Lwt.t;
    m_RequestName : 'a OBus_object.t -> string * int32 -> int32 Lwt.t;
    m_StartServiceByName : 'a OBus_object.t -> string * int32 -> int32 Lwt.t;
    m_UpdateActivationEnvironment :
      'a OBus_object.t -> (string * string) list -> unit Lwt.t;
  }

  let make members =
    OBus_object.make_interface_unsafe interface
      [
        ( OBus_introspect_ext.obus_enum,
          "release_name_result:uint32=3:not_owner,2:non_existent,1:released" );
        ( OBus_introspect_ext.obus_enum,
          "request_name_result:uint32=4:already_owner,3:exists,2:in_queue,1:primary_owner"
        );
        ( OBus_introspect_ext.obus_enum,
          "start_service_by_name_result:uint32=2:already_running,1:success" );
        ( OBus_introspect_ext.obus_flag,
          "request_name_flags:uint32=4:do_not_queue,2:replace_existing,1:allow_replacement"
        );
      ]
      [|
        method_info m_AddMatch members.m_AddMatch;
        method_info m_GetAdtAuditSessionData members.m_GetAdtAuditSessionData;
        method_info m_GetConnectionSELinuxSecurityContext
          members.m_GetConnectionSELinuxSecurityContext;
        method_info m_GetConnectionUnixProcessID
          members.m_GetConnectionUnixProcessID;
        method_info m_GetConnectionUnixUser members.m_GetConnectionUnixUser;
        method_info m_GetId members.m_GetId;
        method_info m_GetNameOwner members.m_GetNameOwner;
        method_info m_Hello members.m_Hello;
        method_info m_ListActivatableNames members.m_ListActivatableNames;
        method_info m_ListNames members.m_ListNames;
        method_info m_ListQueuedOwners members.m_ListQueuedOwners;
        method_info m_NameHasOwner members.m_NameHasOwner;
        method_info m_ReleaseName members.m_ReleaseName;
        method_info m_ReloadConfig members.m_ReloadConfig;
        method_info m_RemoveMatch members.m_RemoveMatch;
        method_info m_RequestName members.m_RequestName;
        method_info m_StartServiceByName members.m_StartServiceByName;
        method_info m_UpdateActivationEnvironment
          members.m_UpdateActivationEnvironment;
      |]
      [|
        signal_info s_NameAcquired;
        signal_info s_NameLost;
        signal_info s_NameOwnerChanged;
      |]
      [||]
end

module Org_freedesktop_DBus_Introspectable = struct
  let interface = "org.freedesktop.DBus.Introspectable"

  let m_Introspect =
    {
      Method.interface;
      Method.member = "Introspect";
      Method.i_args = arg0;
      Method.o_args = arg1 (Some "result", basic_string);
      Method.annotations = [];
    }

  type 'a members = { m_Introspect : 'a OBus_object.t -> unit -> string Lwt.t }

  let make members =
    OBus_object.make_interface_unsafe interface []
      [| method_info m_Introspect members.m_Introspect |]
      [||] [||]
end

module Org_freedesktop_DBus_Peer = struct
  let interface = "org.freedesktop.DBus.Peer"

  let m_GetMachineId =
    {
      Method.interface;
      Method.member = "GetMachineId";
      Method.i_args = arg0;
      Method.o_args = arg1 (Some "machine_id", basic_string);
      Method.annotations = [];
    }

  let m_Ping =
    {
      Method.interface;
      Method.member = "Ping";
      Method.i_args = arg0;
      Method.o_args = arg0;
      Method.annotations = [];
    }

  type 'a members = {
    m_GetMachineId : 'a OBus_object.t -> unit -> string Lwt.t;
    m_Ping : 'a OBus_object.t -> unit -> unit Lwt.t;
  }

  let make members =
    OBus_object.make_interface_unsafe interface []
      [|
        method_info m_GetMachineId members.m_GetMachineId;
        method_info m_Ping members.m_Ping;
      |]
      [||] [||]
end

module Org_freedesktop_DBus_Properties = struct
  let interface = "org.freedesktop.DBus.Properties"

  let m_Get =
    {
      Method.interface;
      Method.member = "Get";
      Method.i_args =
        arg2 (Some "interface_name", basic_string) (Some "member", basic_string);
      Method.o_args = arg1 (Some "value", variant);
      Method.annotations = [];
    }

  let m_GetAll =
    {
      Method.interface;
      Method.member = "GetAll";
      Method.i_args = arg1 (Some "interface_name", basic_string);
      Method.o_args = arg1 (Some "values", dict string variant);
      Method.annotations = [];
    }

  let m_Set =
    {
      Method.interface;
      Method.member = "Set";
      Method.i_args =
        arg3
          (Some "interface_name", basic_string)
          (Some "member", basic_string)
          (Some "value", variant);
      Method.o_args = arg0;
      Method.annotations = [];
    }

  let s_PropertiesChanged =
    {
      Signal.interface;
      Signal.member = "PropertiesChanged";
      Signal.args =
        arg3
          (Some "interface_name", basic_string)
          (Some "updates", dict string variant)
          (Some "invalidates", array basic_string);
      Signal.annotations = [];
    }

  type 'a members = {
    m_Get : 'a OBus_object.t -> string * string -> OBus_value.V.single Lwt.t;
    m_GetAll :
      'a OBus_object.t -> string -> (string * OBus_value.V.single) list Lwt.t;
    m_Set :
      'a OBus_object.t -> string * string * OBus_value.V.single -> unit Lwt.t;
  }

  let make members =
    OBus_object.make_interface_unsafe interface []
      [|
        method_info m_Get members.m_Get;
        method_info m_GetAll members.m_GetAll;
        method_info m_Set members.m_Set;
      |]
      [| signal_info s_PropertiesChanged |]
      [||]
end
